# Java多线程和并发面试题

## 1.有多少种实现线程的方法？

1. 从不同的角度来看有不同的答案。比如说有继承Thread类、实现Runnable接口、实现Callable接口、线程池来创建

2. 但是典型的创建方法就有种继承Thread类和实现Runnable接口

3. 点开Thread类源码发现，其实Thread类继承了Runnable接口，看Thread类的run()方法，本质都是一样的

   ```java
   @Override
   public void run(){
       if(target!=null){
           target.run();
       }    
   }
   ```

   也就是说，“继承Thread然后重写run()方法”和“实现Runnable接口并传入Thread”在实现多线程的方式上并没有本质区别，最后都是调用start来创建线程

4. 其它实现线程的方法，线程池、定时器，细看源码，最后还是逃脱不了本质，最终还是实现Runnable接口或者继承Thread类

5. 结论：其实我们只有一种实现线程的方法，那就是通过Thread类新建线程。但是实现run()方法有两种，第一种是重写run()，第二种是实现Runnable接口的方法，再把Runnable接口的实例传给Thread类。除此之外，其实实现线程的方式，都最终逃脱不了这个范围

## 2.实现Runnable接口和继承Thread类哪个更好？

实现Runnable接口会更好。从三方面去说

1. 代码架构角度：实现Runnable接口可以更好地实现解耦，通过Runnable接口重写run()方法是具体执行的任务，可以让单独一个任务类实现Runnable接口，把实例传给Thread类。并且任务类不负责创建线程的工作，可以把任务类传给不同的Thread类，从而实现解耦。
2. 从资源消耗角度：继承Thread类，每次新建任务时，都要单独新建一个线程，这样开销是很大的。从线程创建到结束销毁。然而工作的内容只是run()函数里面的内容，这种开销是很大的。所以使用Runnable接口和线程池可以很好地减小损耗
3. 从扩展性来看：java是不支持多继承的，继承了Thread类就不能继承其他类了，限制了扩展性。


## 3.一个线程两次调用start()方法会出现什么情况？为什么？

答：会抛出异常。start的时候会检查线程的状态，只有NEW状态下的线程才可以继续，否则会抛出异常。

启动流程：

1. 先检查线程状态，只有NEW状态下线程才可以继续，否则抛出异常
2. 然后加入线程组
3. 最后调用start0()方法启动线程

既然Thread.start()只能调用一次，那么线程池是如何实现复用的？

线程复用的核心关键在于对Thread类进行了包装，它没有重复调用start()方法，而是自己有一个Runnable.run()方法。它在不断地跑，然后不断地检查是否有新的Runnable对象加入，如果有就调用一下run()方法。简单理解就是一个大run()，里面包含着小run()。同一个Thread可以执行不同的Runnable，主要原因是线程和Runnable通过BlockingQueue解耦，线程可以从BlockingQueue中不断获得新的任务。

## 4.既然start()方法会调用run()，为什么不直接调用run()方法？

start()方法才是启动线程的方法，如果调用run()方法，其实跟调用普通方法没有任何区别，跟线程生命周期一点关系都没有
