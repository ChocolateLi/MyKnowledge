# JavaSE和容器相关面试题

## JavaSE基础

### 1、StringBuffer和StringBuilder的区别

StringBuffer和StringBuilder的方法和功能完全是等价的

StringBuffer的方法大都采用了synchonized关键字进行修饰，因此是线程安全的

StringBuilder没有这个修饰，所以是线程不安全的

在单线程环境下，StringBuilder更快，因为它不需要加锁

多线程环境下StringBuffer更安全

### 2、final、finally、finalized区别

**final**

修饰符，可以修饰类、修饰方法、修饰变量。

修饰类表示不能派生出新的子类，即不能被继承。

修饰方法表示不能在子类中被重写。

修饰变量表示不能被修改，只能被读取，必须声明时给定初始值。



**finally**

通常放在try...catch...后面构造最终执行代码块，意味着不管程序是正常执行还是发生异常，该代码块都会执行。

可以将释放外部资源的代码块放在finally中



**finalized**

object类中定义的方法，这个方法是垃圾收集器在销毁对象时调用的，通过重写finalized方法可以执行清理工作。

### 3、==和equals区别

==：如果比较的是基本数据类型，那么比较的是变量的值；如果比较的是引用数据类型，那么比较的是地址值

equals：如果没有重写equals方法，比较的是两对象的地址值；如果重写了equals方法，比较的是对象的属性值

equals方法是从object类中继承的，默认实现就是==

```java
public boolean equals(Object obj) {
        return (this == obj);
}
```

### 4、Java和C++的区别

1. java通过虚拟机实现跨平台，c++依赖于特定的平台
2. java没有指针，它的引用可以理解为指针。c++和c一样都是有指针
3. java支持垃圾自动回收，c++需要手动回收
4. java不支持多重继承，但可以通过实现多个接口来达到目的，c++支持多重继承

语言不是关键，毕竟语言是一种工具，什么项目适合用什么语言，那就使用相应的语言。

### 5、static关键字

#### static关键字的作用

static的作用是方便在没有创建对象时通过类调用方法和变量，优化程序性能

#### static和final的区别

static修饰变量表示静态变量，随着类加载时被初始化，内存中只有一个，所有对象共享静态变量

static修饰方法表示静态方法，在类加载时就存在，不依赖于任何实例

static修饰代码块表示静态代码块，在类加载完成之后就会执行代码块的内容



final修饰类表示不能派生出新的子类，即不能被继承。

final修饰方法表示不能在子类中被重写。

final修饰变量表示不能被修改，只能被读取，必须声明时给定初始值。

#### static方法是否可以被覆盖

static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟任何类的实例都不相关。



### 6、接口和抽象类的区别

1. 抽象类可以有构造方法，接口没有

2. 抽象类可以有非抽象的普通方法，接口所有方法都是抽象的

3. 抽象类中可以有静态方法，而接口中不能包含静态方法

4. 抽象类的抽象方法访问类型可以是public、protect、private，接口的抽象方法只能是public类型的

5. 抽象类可以有普通成员变量，而接口中不能有普通成员变量，它只能有静态成员变量，默认是public static final类型

   

## 容器

### HashMap

#### 1、HashMap原理

hashmap是数组和链表的结合体，数组每个元素存储的是链表的节点，往hashmap里面放键值对的时候，先计算出key的hashcode，再计算出在数组的下标，如果该下标对应的链表为空，则添加成功。如果不为空，则遍历链表是否有相同的key，有就把value替换，如果没有，则添加到链表中。（jdk1.7是添加到链表头节点，jdk1.8是链表尾节点）



#### 2、hashcode和数组下表的计算

hashcode的计算：先用key.hashcode()计算出hash，然后hash>>>16（右移16位），然后高16位异或低16位，即 hash = key.hashcode() ^ key.hashcode()>>>16



数组下标的计算，hash值与length-1按位与，即 h & (length-1)



#### 3、hashmap的扩容机制（jdk1.7）

hashmap初始容量为16，当它达到阈值时，阈值=最大容量*负载因子，每次扩容两倍，总是2的n次方

扩容过程是：使用一个更大的数组来代替小容量的数组，jdk1.7会计算每个元素在数组中的位置，jdk1.8采用比较巧妙的方法。由于数组容量是以2的幂次方扩容的，那么在扩容时，新的位置要么在原来的位置上，要么就是原长度+原位置。



为什么总是2的n次方呢？

可能是方便计算，让数据更加均匀，减少碰撞。



#### 4、put过程

首先调用key所在类的hashcode，计算出hash值，计算出数组下标，并在数组中找到位置。

如果位置为空，直接插入。

如果位置不为空，比较哈希值。如果key的哈希值与所在数据哈希值不同，则直接插入。

若相同，调用equals()方法，返回false，直接插入。返回true，覆盖原来的值



HashMap允许插入键为null的键值对，因为null无法调用hashcode()方法，也就无法确定桶下标，只能通过强制指定。hashmap使用第0个桶存放键为Null的值



#### 5、jdk1.7和jdk1.8 hashmap的不同

1. jdk1.7：数组 + 链表	jdk1.8：数组+链表+红黑树。当链表的元素大于8 并且当前数组大于64时，才会转换为红黑树。
2. jdk1.7底层数组是Entry[]，jdk1.8是Node[]
3. jdk1.7初始化时会创建一个长度为16的数组，而jdk1.8只有首次put的时候才会创建。



#### 6、hashmap为什么是线程不安全的

在并发情况下扩容和rehash的时候会造成环形链表，造成死循环。jdk1.8解决了这个问题，但是在多线程环境下，还是不太建议使用hashmap，因为可能存在数据丢失问题。



可以使用hashtable或者correnthashmap



#### 7、HashMap和HashTable的区别

1. hashmap是线程不安全的，hashtable是线程安全的

2. hashmap可以插入null值，hashtable不行

3. hashtable初始值为11，每次扩容时扩容为原来的2n+1；hashmap初始值为16,每次扩容为2倍

   

#### 8、CorrentHashMap和HashTable的区别

它们的主要区别在于实现线程安全的方式不同。

hashtable，使用synchnoized关键字来保证线程安全，效率非常低下。它会把整张表都锁住。

correnthashmap采用分段锁机制，每一把锁只锁容器的一部分数据。多线程访问不同数据部分时，就不会存在竞争。但是jdk1.8摒弃了segment的概念，采用Node +链表 + 红黑树结构来实现，并发控制采用synchronized和CAS来操作。



这里可能会引申的问题：

**谈谈你对synchonized的理解和CAS**

synchonized解决了多线程访问共享资源造成的数据紊乱，该关键字修饰的方法或者代码块只能允许一个线程访问。

CAS就是比较并交换。它的思想很简单，有三个参数，一个当前内存值V，一个旧的预期值A，一个更新的值B，当且仅当旧的预期值A和当前内存值V相等时，将内存值修改为B，否则什么都不做。



Synchonized是悲观锁

CAS操作的就是乐观锁





#### 9、红黑树

它是自平衡的二叉树

![红黑树](D:\github\MyKnowledgeRepository\picture\红黑树.jpg)



**特性**：

1. 节点不是红色就是黑色
2. 根节点一定是黑色节点
3. 每个叶子节点都是黑色的空节点
4. 红色节点的两个子节点一定是黑色节点
5. 任一节点到叶子节点所有路径都具有相同数量的黑色节点



红黑树怎么自平衡调整？

通过不断的变色和旋转来达到符合以上5个特性，即为平衡状态



红黑树和二叉平衡树的区别？

红黑树放弃了完全平衡，追求大致平衡，与平衡二叉树复杂度相差不大的情况下，保证每次插入最多3次旋转达到平衡，实现更为简单。

二叉平衡树追求绝对的平衡，条件比较苛刻，实现比较麻烦，每次插入新的节点需要旋转的次数未知。



### List

#### 1、ArrayList和Vector的区别

ArrayList是线程不安全的，Vector是线程安全的



#### 2、ArrayList和LinkedList的区别

ArrayList底层是数组结构，支持随机访问，查找的时间复杂度为O(1)。但它插入和删除效率不高，时间复杂度为O(n)

LinkedList底层结构是双向链表，它不支持随机访问，查找的时间复杂度为O(n)。但他插入和删除的效率高。



ArrayList适用于查找多，插入和删除少的场景。

LinkedList适用于查找少，插入和删除多的场景。



#### 3、ArrayList的扩容机制

添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 旧容量的 1.5 倍。

扩容操作需要调用 Arrays.copyOf() 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数























