# 00JavaSE和容器相关面试题

## JavaSE基础

### 1、StringBuffer和StringBuilder的区别

StringBuffer和StringBuilder的方法和功能完全是等价的

StringBuffer的方法大都采用了synchonized关键字进行修饰，因此是线程安全的

StringBuilder没有这个修饰，所以是线程不安全的

在单线程环境下，StringBuilder更快，因为它不需要加锁

多线程环境下StringBuffer更安全

### 2、final、finally、finalized区别

**final**

修饰符，可以修饰类、修饰方法、修饰变量。

修饰类表示不能派生出新的子类，即不能被继承。

修饰方法表示不能在子类中被重写。

修饰变量表示不能被修改，只能被读取，必须声明时给定初始值。



**finally**

通常放在try...catch...后面构造最终执行代码块，意味着不管程序是正常执行还是发生异常，该代码块都会执行。

可以将释放外部资源的代码块放在finally中



**finalized**

object类中定义的方法，这个方法是垃圾收集器在销毁对象时调用的，通过重写finalized方法可以执行清理工作。

### 3、==和equals区别

==：如果比较的是基本数据类型，那么比较的是变量的值；如果比较的是引用数据类型，那么比较的是地址值

equals：如果没有重写equals方法，比较的是两对象的地址值；如果重写了equals方法，比较的是对象的属性值

equals方法是从object类中继承的，默认实现就是==

```java
public boolean equals(Object obj) {
        return (this == obj);
}
```

### 4、Java和C++的区别

1. java通过虚拟机实现跨平台，c++依赖于特定的平台
2. java没有指针，它的引用可以理解为指针。c++和c一样都是有指针
3. java支持垃圾自动回收，c++需要手动回收
4. java不支持多重继承，但可以通过实现多个接口来达到目的，c++支持多重继承

语言不是关键，毕竟语言是一种工具，什么项目适合用什么语言，那就使用相应的语言。

### 5、static关键字

#### static关键字的作用

static的作用是方便在没有创建对象时通过类调用方法和变量，优化程序性能

#### static和final的区别

static修饰变量表示静态变量，随着类加载时被初始化，内存中只有一个，所有对象共享静态变量

static修饰方法表示静态方法，在类加载时就存在，不依赖于任何实例

static修饰代码块表示静态代码块，在类加载完成之后就会执行代码块的内容



final修饰类表示不能派生出新的子类，即不能被继承。

final修饰方法表示不能在子类中被重写。

final修饰变量表示不能被修改，只能被读取，必须声明时给定初始值。

#### static方法是否可以被覆盖

static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟任何类的实例都不相关。



### 6、接口和抽象类的区别

1. 抽象类可以有构造方法，接口没有

2. 抽象类可以有非抽象的普通方法，接口所有方法都是抽象的

3. 抽象类中可以有静态方法，而接口中不能包含静态方法

4. 抽象类的抽象方法访问类型可以是public、protect、private，接口的抽象方法只能是public类型的

5. 抽象类可以有普通成员变量，而接口中不能有普通成员变量，它只能有静态成员变量，默认是public static final类型

   

## 容器

**阅读源码的顺序**

继承关系 -> 变量 -> 内部类 -> 方法

### 常见基础面试题

#### 1、常见的集合有哪些？

Java集合类主要由两个接口**Collection**和**Map**派生出来的，Collection有三个子接口：List、Set、Queue。

List代表了有序可重复集合，可直接根据元素的索引来访问；

Set代表无序不可重复集合，只能根据元素本身来访问；

Queue是队列集合。

Map代表的是存储key-value对的集合，可根据元素的key来访问value。

### HashMap

#### 1、HashMap原理

hashmap是数组和链表的结合体，数组每个元素存储的是链表的节点，往hashmap里面放键值对的时候，先计算出key的hashcode，再计算出在数组的下标，如果该下标对应的链表为空，则添加成功。如果不为空，则遍历链表是否有相同的key，有就把value替换，如果没有，则添加到链表中。（jdk1.7是添加到链表头节点，jdk1.8是链表尾节点）



#### 2、hashcode和数组下表的计算

Hash算法：取key的hashCode值、高位运算、取模运算。

```java
h=key.hashCode() //第一步 取hashCode值
h^(h>>>16)  //第二步 高位参与运算，减少冲突
return h&(length-1);  //第三步 取模运算
```

为什么高16位异或低16位？（为什么右移16位再进行异或操作？）

主要是为了保留高位和低位的信息，这样就能保留目标值的特征，可以减少碰撞。



#### 3、hashmap的扩容机制（jdk1.7）

hashmap初始容量为16，当它达到阈值时，阈值=最大容量*负载因子，每次扩容两倍，总是2的n次方。

扩容过程是：使用一个更大的数组来代替小容量的数组，jdk1.7会计算每个元素在数组中的位置，jdk1.8采用比较巧妙的方法。由于数组容量是以2的幂次方扩容的，那么在扩容时，新的位置要么在原来的位置上，要么就是原长度+原位置。



为什么hashmap的长度总是2的幂次方呢？

是为了取模的时候做优化。

通常的话，hash值范围是比较大的，在求对应的数组下标时，需要先对数组长度取模，得到的元素才是元素存放的位置。

将HashMap的长度定为2 的幂次方，就可以使用 (n-1)&hash的方式，也就是位运算替代取余操作，提高性能。



#### 4、put过程

首先调用key所在类的hashcode，计算出hash值，计算出数组下标，并在数组中找到位置。

如果位置为空，直接插入。

如果位置不为空，比较哈希值。如果key的哈希值与所在数据哈希值不同，则直接插入。

若相同，调用equals()方法，返回false，直接插入。返回true，覆盖原来的值



HashMap允许插入键为null的键值对，因为null无法调用hashcode()方法，也就无法确定桶下标，只能通过强制指定。hashmap使用第0个桶存放键为Null的值



#### 5、jdk1.7和jdk1.8 hashmap的不同

1. jdk1.7：数组 + 链表	jdk1.8：数组+链表+红黑树。当链表的元素大于8 并且当前数组大于64时，才会转换为红黑树。
2. jdk1.7底层数组是Entry[]，jdk1.8是Node[]
3. jdk1.7初始化时会创建一个长度为16的数组，而jdk1.8只有首次put的时候才会创建。



#### 6、hashmap为什么是线程不安全的

jdk1.7采用头插法，在并发情况下扩容和rehash的时候会造成环形链表，造成死循环。jdk1.8解决了这个问题，但是在多线程环境下，还是不太建议使用hashmap，因为可能会发生数据的覆盖从而导致数据丢失问题。



可以使用hashtable或者correnthashmap



#### 7、HashMap和HashTable的区别

1. hashmap是线程不安全的，hashtable是线程安全的

2. hashmap可以插入null值，hashtable不行

3. hashtable初始值为11，每次扩容时扩容为原来的2n+1；hashmap初始值为16,每次扩容为2倍

   

#### 8、CorrentHashMap和HashTable的区别

它们的主要区别在于实现线程安全的方式不同。

hashtable，使用synchnoized关键字来保证线程安全，效率非常低下。它会把整张表都锁住。

correnthashmap采用分段锁机制，每一把锁只锁容器的一部分数据。多线程访问不同数据部分时，就不会存在竞争。但是jdk1.8摒弃了segment的概念，采用Node +链表 + 红黑树结构来实现，并发控制采用synchronized和CAS来操作。



这里可能会引申的问题：

**谈谈你对synchonized的理解和CAS**

synchonized解决了多线程访问共享资源造成的数据紊乱，该关键字修饰的方法或者代码块只能允许一个线程访问。

CAS就是比较并交换。它的思想很简单，有三个参数，一个当前内存值V，一个旧的预期值A，一个更新的值B，当且仅当旧的预期值A和当前内存值V相等时，将内存值修改为B，否则什么都不做。



Synchonized是悲观锁

CAS操作的就是乐观锁



**CorrentHashMap1.7**

![CorrentHashMap1.7](D:\github\MyKnowledgeRepository\img\picture\CorrentHashMap1.7.png)

Segment继承了ReentrantLock

put的过程：



#### 9、红黑树

它是自平衡的二叉树

![红黑树](D:\github\MyKnowledgeRepository\img\picture\红黑树.jpg)



**特性**：

1. 节点不是红色就是黑色
2. 根节点一定是黑色节点
3. 每个叶子节点都是黑色的空节点
4. 红色节点的两个子节点一定是黑色节点
5. 任一节点到叶子节点所有路径都具有相同数量的黑色节点



红黑树怎么自平衡调整？

通过不断的变色和旋转来达到符合以上5个特性，即为平衡状态



**为什么使用红黑树而不是AVL树？**

先说一下红黑树和二叉平衡树的区别：

1.红黑树放弃了完全平衡，追求大致平衡，与平衡二叉树复杂度相差不大的情况下，保证每次插入最多3次旋转达到平衡，实现更为简单。

2.二叉平衡树追求绝对的平衡，条件比较苛刻，实现比较麻烦，每次插入新的节点需要旋转的次数未知。

也就是说红黑树用非严格的平衡来换取增删节点时旋转次数的降低，提高了插入和删除的性能。



#### 10、在解决hash冲突时，为什么先用链表，再转红黑树？

因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡，而单链表不需要。

当元素小于8时，链表结构能够保证查询性能。

当元素大于8时，红黑树的搜索时间是O(logn)，而链表是O(n)，此时需要红黑树加快查询速度，但是插入删除节点效率变慢了；如果一开始就用红黑树，元素太少，插入删除的节点效率又慢，影响性能。



#### 11、LinkedHash底层原理

HashMap是无序的，不能保证插入的顺序。

LinkedHashMap继承于HashMap，是HashMap和LinkedList的融合体，具备两者的特性。每次put操作都会将entry插入到双向链表的尾部。



#### 12、了解TreeMap吗？

TreeMap是一个能比较元素大小的Map集合，会对传入的key进行了大小排序。可以使用元素的自然顺序，也可以使用集合中自定义的比较器来进行排序。



#### 13、HashSet、LinkedHashSet 和 TreeSet 的区别？

`HashSet` 是 `Set` 接口的主要实现类 ，`HashSet` 的底层是 `HashMap`，线程不安全的，可以存储 null 值，add、remove、contain等方法的时间复杂度是O(1)

`LinkedHashSet` 是 `HashSet` 的子类，能够按照添加的顺序遍历；

`TreeSet` 底层使用红黑树，能够按照添加元素的顺序进行遍历，排序的方式可以自定义，add、remove、contain等方法的时间复杂度是O(longn)。



#### 14、HashSet底层实现原理

hashset是基于hashmap实现的，默认构造函数是构建一个初始容量为16，负载因子为0.75的hashmap。封装了一个hashmap 对象来存储所有的集合元素，所有放在 hashset中的集合元素实际上由 hashmap的key来保存，而 hashset中的 hashmap的 value则存储了一个PRESENT的静态object对象



#### 15、让你设计一个hashmap，你如何设计？

第一步，先说一个对hashmap的理解，说一下它原理。

hashmap是数组和链表的结合体，数组每个元素存储的是链表的节点，往hashmap里面放键值对的时候，先计算出key的hashcode，再计算出在数组的下标，如果该下标对应的链表为空，则添加成功。如果不为空，则遍历链表是否有相同的key，有就把value替换，如果没有，则添加到链表中。

hashmap有几个关键点，hash函数，如何处理冲突、如何扩容。

1.设计hash函数。不仅要快，还需要分布均匀，减少碰撞

2.处理冲突。可以采用拉链表的形式来处理，当长度达到一定的时候可以转化为红黑树

3.扩容。当超过一定的节点，是需要扩容的。



### List

#### 1、ArrayList和Vector的区别

ArrayList是线程不安全的，Vector是线程安全的。

大多数情况下不使用Vector，因为操作Vector效率比较低。



#### 2、ArrayList和LinkedList的区别

ArrayList底层是数组结构，支持随机访问，查找的时间复杂度为O(1)。但它插入和删除效率不高，时间复杂度为O(n)

LinkedList底层结构是双向链表，它不支持随机访问，查找的时间复杂度为O(n)。但他插入和删除的效率高。



ArrayList适用于查找多，插入和删除少的场景。

LinkedList适用于查找少，插入和删除多的场景。



#### 3、ArrayList的扩容机制

添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 旧容量的 1.5 倍。

扩容操作需要调用 Arrays.copyOf() 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数



#### 4、了解ArrayDeque吗？

ArrayDeque实现了双端队列，内部使用循环数组实现，默认大小为16。

它的特点：

1. 在两端添加、删除元素的效率较高
2. 根据元素内容查找和删除的效率比较低。
3. 没有索引位置的概念，不能根据索引位置进行操作。

























