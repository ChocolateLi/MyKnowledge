# 常见手撕代码题目

## 排序

### 冒泡排序

```java
/**
 * 冒泡排序
 * @author: 小LeetCode~
 **/
public class Bubble_sort {

    public static void bubbleSort(int [] nums){
        int n = nums.length;//注意
        //标识符，表示这一趟冒泡排序是否有进行元素的交换，有交换则为true，没有交换则为false
        boolean flag = true;
        for (int i = n; i > 1 && flag; i--) {
            flag = false;
            for (int j = 0; j < i - 1; j++) {
                if (nums[j] > nums[j + 1]) {
                    flag = true;
                    swap(nums, j, j + 1);
                }
            }
        }

    }

    private static void swap(int[] nums, int i, int j) {
        int temp = nums[j];
        nums[j] = nums[i];
        nums[i] = temp;
    }

    public static void main(String[] args) {
        int[] nums = {7, 8, 5, 1,3, 4, 9, 6};
        System.out.println(Arrays.toString(nums));
        bubbleSort(nums);
        System.out.println(Arrays.toString(nums));
    }
}
```

注意n=nums.length

第一层循环的条件是i=n，i>1

第二层循环的条件是j=0，j<i-1

### 快速排序

快速排序就是二叉树的前序遍历

```java
/**
 * 快速排序
 * @author: 小LeetCode~
 **/
public class QuickSort {

    public static void main(String[] args) {
        int[] nums = {7, 8, 5, 1, 3, 4, 9, 6};
        System.out.println(Arrays.toString(nums));
        quicksort(nums,0,nums.length-1);
        System.out.println(Arrays.toString(nums));
    }

    private static void quicksort(int[] nums, int left, int right) {
        if(left>=right){
            return;
        }
        //前序遍历
        int mid = partition(nums,left,right);
        quicksort(nums,left,mid-1);
        quicksort(nums,mid+1,right);
    }

    private static int partition(int[] nums, int left, int right) {
        //基准数，一半选取第一个元素
        int x = nums[left];
        int i = left;
        int j = right+1;
        while(true){
            while(nums[++i]<x){
                if(i>=right){
                    break;
                }
            }
            while(nums[--j]>x){

            };
            if(i>=j){
                break;
            }
            swap(nums,i,j);
        }
        swap(nums,left,j);
        return j;
    }

    private static void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}

```

注意if的判断条件是left>=right，right=nums.length-1

quicksort(nums,left,mid-1);注意是mid-1
quicksort(nums,mid+1,right);注意是mid+1

### 归并排序

归并排序就是二叉树的后序遍历

```java
/**
 * 归并排序
 *
 * @author: 小LeetCode~
 **/
public class MergeSort {

    public static void main(String[] args) {
        int[] nums = {7, 8, 5, 1,3, 4, 9, 6};
        System.out.println(Arrays.toString(nums));
        mergesort(nums, 0, nums.length - 1);
        System.out.println(Arrays.toString(nums));
    }

    private static void mergesort(int[] nums, int left, int right) {
        if (left >= right) {
            return;
        }
        int mid = (left+right)/2;//2的1次方
        mergesort(nums, left, mid);
        mergesort(nums, mid + 1, right);
        merge(nums, left, mid, right);
    }

    private static void merge(int[] nums, int left, int mid, int right) {
        int temp[] = new int[right-left+1];
        int i = left;
        int j = mid + 1;
        int k = 0;
        while (i <= mid && j <= right) {
            if (nums[i] <= nums[j]) {
                temp[k++] = nums[i++];
            }else{
                temp[k++] = nums[j++];
            }
        }
        while(i<=mid){
            temp[k++] = nums[i++];
        }
        while(j<=right){
            temp[k++] = nums[j++];
        }

        //把临时数组赋值给原来的数组
        for (int x = 0; x < temp.length ; x++) {
            nums[left+x] = temp[x];
        }
    }
}

```

注意if的判断条件是left>=right，right=nums.length-1

注意mid的取值

mergesort(nums, left, mid);
mergesort(nums, mid + 1, right);

### 堆排序

```

```



## 二叉树非递归遍历

### 前序遍历

访问顺序：根节点、左子树、右子树

```java
/**
     * 迭代前序遍历
     * @param root
     */
private static void pre_travers_iterator(TreeNode root) {
    Deque<TreeNode> stack = new ArrayDeque<>();
    TreeNode cur = root;
    while (cur!=null || !stack.isEmpty()) {
        if (cur != null) {
            System.out.print(cur.val + " ");//前序遍历代码
            stack.push(cur);
            cur = cur.left;
        }else{
            cur = stack.pop();
            //中序遍历代码写这里
            cur = cur.right;
        }
    }

}
```



### 中序遍历

访问顺序：左子树、根节点、右子树

```java
/**
     * 迭代中序遍历
     * @param root
     */
private static void in_travers_itrator(TreeNode root) {
    ArrayDeque<TreeNode> stack = new ArrayDeque<>();
    TreeNode cur = root;
    while (cur!=null || !stack.isEmpty()) {
        if(cur != null) {
            stack.push(cur);
            cur = cur.left;
        }else{
            cur = stack.pop();
            System.out.print(cur.val + " ");
            cur = cur.right;
        }
    }
}
```



### 后序遍历

```java
/**
     * 迭代后序遍历
     * @param root
     */
private static void post_travers_iterator(TreeNode root) {
    ArrayDeque<TreeNode> stack_main = new ArrayDeque<>();
    ArrayDeque<TreeNode> stack_help = new ArrayDeque<>();
    stack_help.push(root);
    while (!stack_help.isEmpty()) {
        TreeNode cur = stack_help.pop();
        stack_main.push(cur);
        if (cur.left != null) {
            stack_help.push(cur.left);
        }
        if (cur.right != null) {
            stack_help.push(cur.right);
        }
    }

    while (!stack_main.isEmpty()) {
        TreeNode node = stack_main.pop();
        System.out.print(node.val + " ");
    }
}
```



## LRU缓存淘汰算法

**算法链接**

[LRU缓存机制](https://leetcode-cn.com/problems/lru-cache/)



**算法描述**

LRU 算法实际上是让你设计数据结构：首先要接收一个 capacity 参数作为缓存的最大容量，然后实现两个 API，一个是 put(key, val) 方法存入键值对，另一个是 get(key) 方法获取 key 对应的 val，如果 key 不存在则返回 -1。

注意哦，get 和 put 方法必须都是 O(1) 的时间复杂度



**算法设计**

要让 put 和 get 方法的时间复杂度为 O(1)，我们可以总结出 cache 这个数据结构必要的条件：查找快，插入快，删除快，有顺序之分



哈希表查找快，但是数据无固定顺序；链表有顺序之分，插入删除快，但是查找慢。所以结合一下，形成一种新的数据结构：哈希链表。



LRU 缓存算法的核心数据结构就是哈希链表，双向链表和哈希表的结合体。这个数据结构长这样

![哈希链表](D:\github\MyKnowledgeRepository\picture\哈希链表.jpg)





**算法实现**



链表节点的实现

```java
class Node {
    public int key, val;
    public Node next, prev;
    public Node(){}
    public Node(int k, int v) {
        this.key = k;
        this.val = v;
    }
}
```

双向链表的实现

```java
class DoubleList {
    
    Node head;
    Node tail;
    int size;
    //实现一个伪头节点和伪尾节点
    public DoubleList(){
        this.head = new Node();
        this.tail = new Node();
        head.next = tail;
        tail.pre = head;
        this.size = 0;
    }
    
    // 在链表头部添加节点 node，时间 O(1)
    public void addFirst(Node node){
        node.pre = head;
        node.next = head.next;
        head.next.pre = node;
        head.next = node;
        size++;
    }

    // 删除链表中的 node 节点（node 一定存在）
    // 由于是双链表且给的是目标 Node 节点，时间 O(1)
    public void remove(Node node){
        node.pre.next = node.next;
        node.next.pre = node.pre;
        size--;
    }
    
    // 删除链表中最后一个节点，并返回该节点，时间 O(1)
    public Node removeLast(){
        Node node = tail.pre;
        remove(node);
        return node;
    }
    
    // 返回链表长度，时间 O(1)
    public int size(){
        return size;
    }
}
```



缓存结构实现

```java
class LRUCache {
    // key -> Node(key, val)
    private HashMap<Integer, Node> map;
    // Node(k1, v1) <-> Node(k2, v2)...
    private DoubleList cache;
    // 最大容量
    private int cap;
    
    public LRUCache(int capacity) {
        this.cap = capacity;
        map = new HashMap<>();
        cache = new DoubleList();
    }
    
    public int get(int key) {
        if (!map.containsKey(key))
            return -1;
        int val = map.get(key).val;
        // 利用 put 方法把该数据提前
        put(key, val);
        return val;
    }
    
    public void put(int key, int val) {
        // 先把新节点 x 做出来
        Node x = new Node(key, val);
        
        if (map.containsKey(key)) {
            // 删除旧的节点，新的插到头部
            cache.remove(map.get(key));
            cache.addFirst(x);
            // 更新 map 中对应的数据
            map.put(key, x);
        } else {
            if (cap == cache.size()) {
                // 删除链表最后一个数据
                Node last = cache.removeLast();
                map.remove(last.key);
            }
            // 直接添加到头部
            cache.addFirst(x);
            map.put(key, x);
        }
    }
}
```



## 多线程

### 使用两个现程交替打印0~100的奇偶数

1、Synchronized方法

```java
package com.Thread.threadcoreknowledge.threadobjectcommonmethod;

/**
 * 描述：使用synchronized方法来回交替打印奇偶数
 */
public class WaitNotifyPrintOddEvenSyn {

    private static int count = 0;
    private static Object lock = new Object();

    public static void main(String[] args) {
        Thread even_thread = new Thread(new Runnable() {
            @Override
            public void run() {
                while (count<=100){
                    synchronized (lock){
                        if((count & 1)==0){
                            System.out.println(Thread.currentThread().getName()+":"+count);
                            count++;
                        }
                    }
                }
            }
        },"偶数");
        Thread odd_thread = new Thread(new Runnable() {
            @Override
            public void run() {
                while (count<100){
                    synchronized (lock){
                        if((count & 1)==1){
                            System.out.println(Thread.currentThread().getName()+":"+count);
                            count++;
                        }
                    }
                }
            }
        },"奇数");

        even_thread.start();
        odd_thread.start();
    }

}

```

2、使用wait()和notify()方法

```java
package com.Thread.threadcoreknowledge.threadobjectcommonmethod;

/**
 * 描述：使用wait和notify来回交替打印奇偶数
 */
public class WaitNotifyPrintOddEveWait {

    private static int count = 0;
    private static Object lock = new Object();

    static class Odd_Even_Thread implements Runnable{

        @Override
        public void run() {
            synchronized (lock){
                while (count<=100){
                    System.out.println(Thread.currentThread().getName()+":"+count++);
                    lock.notify();
                    //如果任务还没结束，就让出当前这把锁
                    if(count<=100){
                        try {
                            lock.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            }
        }
    }

    public static void main(String[] args) {
        Odd_Even_Thread odd_even_thread = new Odd_Even_Thread();
        Thread t1 = new Thread(odd_even_thread,"偶数");
        Thread t2 = new Thread(odd_even_thread,"奇数");
        t1.start();
        t2.start();

    }

}

```



### 使用wait实现生产者消费者模式

```java
package com.Thread.threadcoreknowledge.threadobjectcommonmethod;

import java.util.Date;
import java.util.LinkedList;

/**
 * 描述：生产者消费者模式，不能使用阻塞队列
 */
public class ProducerComsumerMode {

    public static void main(String[] args) {
        EvenStorage storage = new EvenStorage();
        Producer producer = new Producer(storage);
        Comsumer comsumer = new Comsumer(storage);
        Thread produce_thread = new Thread(producer);
        Thread comsumer_thread = new Thread(comsumer);
        produce_thread.start();
        comsumer_thread.start();
    }
}

class EvenStorage{
    private int maxSize;
    private LinkedList<Date> storage;

    public EvenStorage() {
        maxSize = 10;
        storage = new LinkedList<>();
    }

    public synchronized void put(){
        while (storage.size()==maxSize){
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        storage.add(new Date());
        System.out.println("仓库里有"+storage.size()+"件产品");
        notify();
    }

    public synchronized void take(){
        while (storage.size()==0){
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println("拿到了"+storage.poll()+"，仓库现在还剩"+storage.size()+"件产品");
        notify();
    }
}

class Producer implements Runnable{

    public EvenStorage storage;

    public Producer(EvenStorage storage) {
        this.storage = storage;
    }

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            storage.put();
        }
    }
}

class Comsumer implements Runnable{

    private EvenStorage storage;

    public Comsumer(EvenStorage storage) {
        this.storage = storage;
    }

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {

            storage.take();
        }
    }
}

```



### 使用BlockingQueue实现的生产者消费者模式

```java
package com.Thread.Test;

import java.util.Date;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingDeque;

/**
 * 使用BlockingQueue实现生产者消费者模式
 * @author: 小LeetCode~
 **/
public class ProducerComsumerMode {

    public static void main(String[] args) {
        BlockingQueue<Date> queue = new LinkedBlockingDeque<>();
        Producer producer = new Producer(queue);
        Comsumer comsumer = new Comsumer(queue);
        Thread producerThread = new Thread(producer);
        Thread comsumerThread = new Thread(comsumer);
        producerThread.start();
        comsumerThread.start();
    }
}

class Producer implements Runnable {

    BlockingQueue<Date> queue;

    public Producer(BlockingQueue<Date> queue){
        this.queue = queue;
    }

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            try {
                queue.put(new Date());
                System.out.println("生产了,"+"仓库里有（"+ queue.size() +")件产品");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

class Comsumer implements Runnable {

    BlockingQueue<Date> queue;

    public Comsumer(BlockingQueue<Date> queue) {
        this.queue = queue;
    }

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            try {
                queue.take();
                System.out.println("消费了,"+"仓库里还有（"+ queue.size() +")件产品");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```





