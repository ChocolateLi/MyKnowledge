# Redis、MySQL技术原理总结

## Redis

### 1、Redis数据类型

键的类型只能为字符串

值支持五种数据类型

string：字符串

list：列表

set：无序集合

hash：散列表

zset：有序集合。带分数的set

### 2、缓存穿透、缓存雪崩、缓存击穿

#### 缓存穿透

缓存穿透是指查询一个一定不存在的数据，比如id=-1，由于缓存命不中，就会去查询数据库，查询不到数据则不会写入缓存，这就导致了这个不存在的数据每次请求都要到数据库查询，一旦并发点高，就会造成缓存穿透。

![缓存穿透](D:\github\MyKnowledgeRepository\picture\缓存穿透.png)



**解决方案：**

1. 将空对象也缓存起来，并给它设置很短的时间，最长不超过5分钟
2. 采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被布隆过滤器拦截掉，从而避免对底层存储系统的查询压力。

#### 缓存雪崩

如果缓存集中在一段时间内失效，发生大量缓存穿透，所有查询都落到数据库上，就会造成缓存雪崩。

![缓存雪崩](D:\github\MyKnowledgeRepository\picture\缓存雪崩.png)

**解决方案：**

把每个key失效的时间加上一个随机值，尽量让失效的时间点分布在不同时间点上。



#### 缓存击穿

是指一个key非常热点，在不停地扛着大并发，当这个key失效时，持续的大并发量穿透缓存，直接请求数据库。就像一个屏障凿开了一个洞



**解决方案：**

设置Key永不过时



### 3、布隆过滤器 Bloom Filter

#### 概念

布隆过滤器实际上是一个很长的二进制向量和一系列随机映射函数。

布隆过滤器可以用于检索一个元素是否在集合中



优点：算法效率高

缺点：有一定的误识别率和删除困难

#### 原理

当一个元素加入集合时，通过K个散列函数将这个元素映射成数组的K个点，把它们置为1。检索时，看这些点是不是都是1，就大概知道这个元素在不在集合里。如果这些点有任何一个0，则被检索的元素一定不在集合里。如果都是1，则可能在集合里。



Bloom Filter跟单哈希函数Bit-Map的区别在于：它使用了K个哈希函数，每个元素跟K个bit对应，从而降低冲突的概率

![Bloom Filter](D:\github\MyKnowledgeRepository\picture\布隆过滤器.png)

### 4、哨兵模式

在一个主从复制的集群中，如果主机挂掉了，哨兵会从从机中挑选一台作为主机，并且设置它为从机的主机。如果之前的主机再次启动，也会成为从机。



### 5、Redis的持久化

**RDB持久化**：对Redis的数据执行周期性地持久化，可以将某个时间点的所有数据都存放在磁盘上。可以将快照复制到其他服务器从而创建具有相同数据的服务器副本

**AOF持久化**：将每条写入命令作为日志写入到日志文件中，这个模式是只追加模式。



### 6、Redis单线程，为什么那么快？

1. 完全基于内存，速度非常快
2. 采用单线程，就避免了不必要的上下文切换和竞争条件，也就不会有多线程的切换导致消耗CPU，就不存在加锁释放锁的操作，也不会因为死锁而导致性能消耗。
3. 使用了多路I/O复用模型，非阻塞I/O



### 7、什么是缓存一致性？



### 8、缓存和数据库(MySQL)双写一致性问题







## MySQL

### 1、MySQL存储引擎

| 对比项 | MyISAM                 | InnoDB                   |
| :----- | ---------------------- | ------------------------ |
| 外键   | 不支持                 | 支持                     |
| 事务   | 不支持                 | 支持                     |
| 锁     | 表级锁，不支持行级锁   | 行级锁，支持表级锁       |
| 缓存   | 只缓存索引，不缓存数据 | 不仅缓存索引，还缓存数据 |

MyISAM适合场景

1. 频繁执行全表count的语句
2. 对数据执行增删改的效率不高，查询非常频繁
3. 没有事务



InnoDB适合场景

1. 适合数据增删改频繁

2. 可靠性比较高，支持事务

   

### 2、索引

#### 何为索引？有什么用？优缺点？

索引用于快速查询和检索数据的数据结构。

索引的作用就相当于目录，它可以快速地帮我们找到数据的位置



优点：加快数据检索的速度，减少服务器需要扫面的行数

缺点：创建索引和维护索引需要耗费时间。索引是存储到磁盘文件上的，所以需要耗费一些存储空间

#### 索引数据结构

常见的索引数据结构有：Hash、B树、B+树



**Hash**

通过哈希算法可以快速找到数据的index位置。

如果发生了哈希冲突，则采用拉链法来解决。这里可以引申到 JDK 上的 HashMap

最大的缺点：不支持顺序和范围查询。它只能精确地查询。无法用于分组和排序



**B树**

![B树](D:\github\MyKnowledgeRepository\picture\B树.png)



B树的特征：

1. 每个节点最多m个孩子，m被称为树的阶，K的值取决于磁盘页的大小
2. 每个节点最多存储m-1个关键字。根节点至少一个关键字，非根节点至少m/2个关键字
3. 每个节点的关键字都是从小到大排序的。
4. 所有叶子节点都位于同一层

拿上图来说，8和12有三个子节点，所以阶数为3



**B+树**

![B+树](D:\github\MyKnowledgeRepository\picture\B+树.png)

![B+树](D:\github\MyKnowledgeRepository\picture\B+树2.png)



B+树与B树有什么区别？

1. B树所有的节点都存放键(key)也存放数据(data)，B+树只有叶子节点才存放key和data，其他节点只存放key
2. B树的叶子节点都是独立的，B+树有一条引用链指向它相邻的叶子节点
3. B树的检索过程相当于对范围内的每个节点的关键字做二分查找，可能还没到叶子节点，检索就结束了；B+树的检索效率就很稳定，任何查找都是从根节点到叶子节点的过程。



在MySQL中。MyISAM引擎和InnoDB引擎都是采用B+树作为索引结构



#### 索引类型

**主键索引**

数据表使用的主键列就是主键索引



一张数据表只有一个主键列，并数据不能为空，不能重复



在MySQL的InnoDB的表中，如果没有指定主键，InnoDB会自动检查表中是否有唯一索引的字段，如果有，把该字段设为默认主键，如果没有，创建一个6Byte的自增主键



**二级索引（辅助索引）**

二级索引又称为辅助索引，因为二级索引的叶子节点存储的是主键。也就是说，通过二级索引可以定位主键的位置。

唯一索引、普通索引、前缀索引都属于二级索引



唯一索引：唯一索引的属性列不能出现重复数据，但可以为Null，一张表允许创建多个唯一索引。建立唯一索引大部分是为了这一属性列的数据唯一，而不是为了查询效率。

普通索引：普通索引允许数据重复和Null，一张表可以创建多个普通索引，它的唯一作用是为了快速查询数据。

前缀索引：前缀索引只使用字符类型的数据。就是对文本前面几个字符创建索引



#### 聚簇索引与非聚簇索引

**聚簇索引**

聚簇索引即索引结构和数据一起存放的索引，主键索引就是聚簇索引



优点：

速度非常快，B+树本身是一个多叉平衡树，叶子节点都是有序，一旦定位到了索引，就定位到了数据



缺点：

1、依赖有序的数据。如果索引的数据不是有序的话，那查找起来非常慢。

2、更新代价大。如果索引列的数据被修改时，对应的索引也就将修改。而且聚簇索引的叶子节点还存放着数据，修改代价是比较大的。



**非聚簇索引**

非聚簇索引即索引结构和数据分开存放的索引。



优点：

更新代价小。非聚簇索引的叶子节点是不存放数据

缺点：

1、跟聚簇索引一样，也依赖于有序的数据。

2、可能会二次查询（即回表）。这是非聚簇索引最大的缺点。当查找到索引对应的主键后，可能还需要根据主键再到数据文件或者表中查询。

比如：select * from table where name='小力哥'

执行的流程是先查询到name索引上的‘小力哥’，然后找到他的id是3，最后去主键索引，找到id为3的对应的值。



非聚簇索引一定回表查询吗？

不一定。可以通过覆盖索引。如果一个索引包含所需要查询的字段的值，称之为覆盖索引。



#### 索引优化

1. 在查询时，索引不能是表达式的值，也不能是函数的参数，否则无法使用索引
2. 在使用多列作为查询条件时，使用多列索引比单列索引效率高
3. 让选择性强的索引放在前面
4. 前缀索引。对于Text、Varchar类型的列必须使用前缀索引
5. 覆盖索引。索引包含所需要查询字段的值



#### 联合索引的索引最左匹配原则

所谓的联合索引就是多列索引。比如(a,b,c,d)

MySQL会一直向右匹配直到遇到范围查询（<、>、between、like）就停止匹配。

如，有联合索引(a,b,c,d)，查询条件为a=1 and b=2 and c<3 and d=4，则会在节点依次命中 a、b、c，不会命中d。（因为c是范围查询）



#### 索引是建立的越多越好吗？

不是。

1. 小表是不需要建立索引。
2. 数据变更是需要维护索引的。更多的索引意味着更多的维护成本
3. 更多的索引也意味着更多的空间



### 3、事务

#### 事务的四大特性（ACID）

原子性。要么都做，要么都不做。

一致性。事务对读取同一个数据，结果应该是相同的。

隔离性。一个事务的执行不能被其他事务干扰。

持久性。一旦事务提交，所做的修改永久保存在数据库中。

#### 事务的并发问题

1. 丢失修改。一个事务的更新操作被另一个事务的更新操作给替换了。

   如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。

   ![丢失修改](D:\github\MyKnowledgeRepository\picture\丢失修改.png)

   

2. 脏读。当前事务读取到另一个事务未提交的数据。

   如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据

   ![脏读](D:\github\MyKnowledgeRepository\picture\脏读.png)

   

3. 不可重复读。一个事务读取同一数据集时，在这事务未结束时，另一个事务也访问了同一数据，并做了修改，导致第一个事务两次读取的结果不一致。

   例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同

   ![不可重复读](D:\github\MyKnowledgeRepository\picture\不可重复读.png)

   

4. 幻影读。幻影读也属于不可重复读的一种。一个事务T读取同一范围内数据，另一个事务在这个范围内插入或者删除了一条数据，当事务T再次读取时，两次读取结果不同。

   ![幻影读](D:\github\MyKnowledgeRepository\picture\幻影读.png)

   

#### 事务隔离级别

1. 未提交读(read uncommited)。事务的修改即使是未提交读，对其他事务也是可见的。
2. 提交读(read commited)。一个事务只能读取已提交的事务所做的修改。可解决脏读问题
3. 可重复读(repeatable read)。保证一个事务读取同一个数据结果是一样的。可解决不可重复读的问题
4. 串行化(serielizable)。该隔离级别需要加锁，保证同一时间只有一个事务执行。可解决幻影读问题



0表示不能解决，1表示能解决

|            | 未提交读 | 提交读 | 可重复读 | 串行化 |
| ---------- | -------- | ------ | -------- | ------ |
| 脏读       | 0        | 1      | 1        | 1      |
| 不可重复读 | 0        | 0      | 1        | 1      |
| 幻影读0    | 0        | 0      | 0        | 1      |



### 4、锁

#### 锁的分类

按粒度划分：表级锁、行级锁

按锁级别划分：共享锁、排它锁

按使用方式划分：乐观锁、悲观锁



**表级锁和行级锁**

表级锁：锁住整张表

行级锁：锁住表中的某一个行



**共享锁和排它锁**

共享锁：又称读锁。一个事务对数据对象加了读锁，可以对该对象执行读取操作，但是不能进行更新操作。加锁期间，其他事务能对它加读锁，但不能加写锁。

排它锁：又称写锁。一个事务对数据对象加了写锁之后，可以对该对象执行读取和更新操作。加锁期间，其他事务不能对它加任何锁。



**乐观锁和悲观锁**

乐观锁和悲观锁是两种思想，用于解决并发场景下的数据竞争问题

乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候，判断一下在此期间别人有没有修改过数据，如果有，则放弃操作，否则执行操作。Redis使用的就是乐观锁

悲观锁：悲观锁在操作数据时非常悲观，认为别人会同时修改数据。因此操作数据时，直接把数据锁住，直到操作完成后才释放锁。上锁期间其他人不可修改数据



#### 并发控制MVCC，MySQL InnoDB MVCC实现机制







