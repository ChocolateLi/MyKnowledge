# 计算机网络、操作系统内容总结

## 计算机网络

### 一、基础知识

#### 1、五层网络结构

![五层网络结构](D:\github\MyKnowledgeRepository\picture\五层网络模型.png)



**应用层**

应用层的任务是为应用程序的交互提供服务的。

应用层协议定义的是应用进程间的交互和通信规则。



如：万维网协议HTTP、域名系统DNS、文件上传协议FTP、支持邮件的SMTP协议

应用层交互的数据单元称为报文



**传输层**

传输层的任务是为两台主机进程间的通信提供通用的数据传输服务的。

所谓的“通用的”并不是针对特定网络应用，而是多种应用都可以使用同一个传输层服务。



应用进程利用该服务传输应用报文。



一台主机可以同时运行多个进程。因此传输层有复用和分用的功能。

复用，指的是多个应用进程可以同时使用传输层服务。

分用，指的是传输层把收到的信息分别交互给应用层的各个进程。



两种协议

TCP - 面向连接，提供可靠传输

UDP - 提供无连接，尽最大努力交互



**网络层**

在计算机网络中进行通信的两台计算机，可能会经过很多数据链路层，经过很多通信子网。

网络层的任务就是选择合适的路由和交换节点，确保数据及时传送。



在发送数据时，网络层会把传输层的报文段或用户数据报封装成分组和包进行传送。

常用协议：IP、ARP、RARP、ICMP、IGMP



**数据链路层**

两台主机的数据传输总是在一段一段的链路上传输的，因此需要专门的数据链路协议。

两个相邻节点之间传输数据时，数据链路层会将网络层交下来的IP数据报封装成帧，在两个相邻的节点上传送帧。



常用协议：ARQ



**物理层**

物理层传输的最小单位是比特。

物理层的作用是实现相邻计算机之间比特流的传输，它尽可能屏蔽传输介质和物理设备的差异。

#### 2、面试常见协议

**ARP协议的工作原理**

网络层的ARP协议的作用是完成IP地址与物理地址的映射。

1. 每台主机都有自己的ARP缓冲区列表，记录着IP地址和MAC地址的映射关系

2. 当源主机向目标主机发送数据包时，先从ARP列表中查询目标主机的IP地址对应的MAC地址；如果有，直接将数据包发给MAC地址这个；如果没有，则发起一个广播，查询目标主机对应的MAC地址

3. 网络中的所有主机收到ARP请求后，都会查询目的IP是否和自己的IP相同；若相同，会将发起请求的IP地址和MAC地址存储在自己的ARP列表中，并向源主机发送ARP响应包，告诉对方它就是你要找的MAC地址主机。

4. 源地址主机收到ARP响应包后，会将里面的IP地址和MAC地址存在自己的ARP列表中，然后利用此信息开始传输数据。

   

**TCP的主要特点是什么**

1. TCP是面向连接的
2. TCP的连接只有有两个端点，即它是点对点的
3. TCP提供可靠交付。即TCP连接传送的数据是无差错、不丢失、不重复、并且按序达到。
4. TCP提供全双工通信。即TCP允许通信双方的应用程序在任何时候都可以发送数据。
5. 它是面向字节流的。即把应用层传下来的报文看成字节流，把字节流组成大小不等的数据块。



**UDP的主要特点是什么**

1. UDP面向无连接
2. UDP允许一对一、一对多、多对多发送信息
3. UDP是尽最大努力交付
4. UDP没有拥塞控制。即它不管网络阻不阻塞，它就是一直发数据
5. UDP是面向报文的。即应用传下来的报文不合并不拆分，只添加UDP头部。



**TCP和UDP的区别**

TCP和UDP的特点就是它们的区别



### 二、TCP/IP

#### 1、TCP三次握手、四次挥手

##### 1、TCP三次握手过程

![TCP三次握手过程](D:\github\MyKnowledgeRepository\picture\TCP三次握手.png)

- 首先，客户端和服务端都处于close状态，服务器主动监听某个端口号，处于listen状态
- 客户端会随机初始化序列号，将此序列号置于TCP首部的’序列号‘字段中，同时把SYN标志置为1，表示SYN报文。接着把第一个SYN报文发给服务端，客户端处于syn-sent状态。（该报文不包含应用层数据）
- 服务端收到客户端的SYN报文后，也随机初始化自己的序列号，将此序列号置于TCP首部的'序列号'字段中，其次把TCP首部的’确认应答号‘字段填入客户端的序列号+1，接着把SYN和ACK标志置为1，把该报文发给客户端。之后服务端处于SYN-RCVD状态。（该报文不包含应用层数据）
- 客户端收到服务端的报文后，先将ACK标志置为1，在自己的‘确认应答号’字段中填入服务端序列号+1，最后把报文发给服务端。客户端处于estab-lished状态。（该报文可以携带应用层数据）
- 服务端收到客户端应用报文后，也进入estab-lished状态。



第三次握手可以携带数据，前两次握手不可携带数据。



##### 2、TCP四次挥手过程

![TCP四次挥手过程](D:\github\MyKnowledgeRepository\picture\TCP四次挥手.png)

1. 客户端发送释放报文（即TCP首部FIN标志置为1的报文，FIN报文）。之后客户端进入FIN_WAIT_1状态
2. 服务端收到之后，发送ACK应答报文。之后服务端进入CLOSE_WAIT状态。（此时，服务端能向客户端发数据，但是客户端不能向服务端发数据）
3. 客户端收到服务端ACK报文后，进入FIN_WAIT_2状态
4. 当服务端不再需要连接时，发送释放报文，FIN=1。之后服务端进入last-ack状态
5. 客户端收到服务端的FIN报文后，发送ACK应答报文给服务端。之后客户端进入Time_wait状态。
6. 服务端收到ACK应答报文后，进入close状态。
7. 客户端经过2MSL(最大报文存活时间)一段时间后进入close状态



##### 3、为什么是三次握手？不是两次、四次？

**两次握手**：无法防止历史连接的建立，造成双方资源的浪费。比如客户发出的第一个请求连接报文没有丢失，而是因为在网络上停留太长，服务端连接释放以后才达到。但是这是一个早已失效的报文，服务端误以为这是客户端又一次新的请求，就向客户端发送确认报文，同意连接。如果不进行第三次握手，服务端就会一直等待客户端发信息，导致资源白白浪费。



**四次握手**：三次握手理论上是最少可靠连接了，所以不需要使用更多的通信次数。



##### 4、为什么需要四次挥手？

四次挥手的原因是确保双方都没有数据要发送了。



举个例子：A和B通话，A把话讲完了，跟B说："好啦，我已经没有话说了"，B回复说：”好的，我知道了"。但是此时B还没有把话讲完，接着B吧啦吧啦讲完，最后B说：”好啦，我也讲完啦“，A回答：”知道啦！“。至此双方通话才结束。



##### 5、为什么Time_wait等待时间是2MSL

time_wait等待2MSL，比较合理的解释是：数据包一来一回需要等待2倍的时间。



MSL是报文最大生存时间。

TCP报文是基于IP协议的，IP头中有一个TTL字段，它表示是IP数据包可以经过的最大路由数，没经过一个处理它的路由，此值减1，直到为0，则将数据报丢弃。

MSL与TTL的区别：MSL是以时间为单位，TTL是经过路由跳数。所以MSL的时间要大于TTL消耗为0的时间，以确保报文自然凋亡。

等待2MSL也是为了本次连接发送的报文在网络中自然消亡，避免影响下一次连接中出现旧报文的情况。



等待2MSL也是为了确保最后一个ACK报文到达服务端。这个报文很可能丢失，导致服务端收不到确认报文。所以服务端会超时重传释放报文，客户端就能在2MSL的时间里再次发送确认报文。



##### 6、为什么需要time_wait状态？

主动发起关闭连接的一方，才有time_wait状态。

它是为了保证被动关闭的一方能正确关闭。既保证最后的ACK确认报文能被被动关闭方收到，从而帮助其关闭。



##### 7、如果建立连接，但是客户端突然出现故障怎么办？

TCP有一个保活机制。它的原理是这样的，定义一个时间段，在这个时间段内，没有任何连接活动，TCP保活机制开始起作用。每隔一段时间，发送一个探测报文，如果连续几个探测报文没有响应，则认为当前TCP连接已死亡，接着就关闭此连接。



#### 2、TCP协议如何保证可靠传输？

1. 数据包校验。若数据在传输过程中发生了变化，校验出包有错，则丢弃报文段不给响应。
2. 对失序数据包重排序。TCP报文段采用IP数据报来传输，IP数据报的达到可能会失序，因此TCP报文段也可能会失序。TCP对失序的数据进行重排序，然后上交给应用层。
3. TCP接收端会丢弃重复的数据。
4. 流量控制。TCP连接的每一方都有固定大小的缓冲区，TCP接收端只允许另一方发送接收端缓冲区所能容纳的数据。都接受端来不及处理发送端的数据时，会提示发送方降低发送速率，防止包丢失。TCP是利用滑动窗口来实现流量控制的
5. 拥塞控制。当网络阻塞时，减少数据发送。
6. 超时重传。当TCP发出一个段后，会启动一个定时器，等待目的端确认收到这个报文。如果不能及时确认，将重发这个报文段。
7. ARQ协议。它的基本原理就是每发完一个分组就停止发送，等待对方确认，在收到确认后，再发下一个分组。



##### 1、滑动窗口和流量控制

TCP通过滑动窗口实现流量控制。

滑动窗口是一个流量控制技术。

流量控制是为了控制发送方的速率，保证接收方来得及接受。

接收方的确认报文中的窗口字段可以用来控制发送方的窗口大小，从而影响发送方的发送速率。

将窗口字段设为0，则发送方不能发送数据。



##### 2、拥塞控制以及相关算法

拥塞控制和流量控制不同。拥塞控制是全局性的过程，流量控制是点对点通信量的控制。

在某段时间，若对网络中某一资源的需求超过该资源所能提供的有用部分，网络的性能就会变坏，这种情况就是拥塞。



拥塞控制是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不至于过载。

拥塞控制是一个全局性的过程，涉及到所有主机、所有路由器，以及与降低网络性能所有有关的因素。

相反流量控制是一个点对点通信量的控制，是个端到端的问题。

流量控制所要做的就是抑制发送端发送数据的速率，以便接收端来的及接收。



为了进行拥塞控制，TCP发送方要维持一个拥塞窗口(cwnd)的状态变量。

拥塞窗口的大小取决于网络的拥塞程度，并且动态变化。

发送方窗口让自己的发送窗口取为拥塞窗口和接收方的接收窗口较小的一个。



TCP拥塞控制采用了四种算法：慢开始、拥塞避免、快重传和快恢复。

**慢开始**：就是由小到大逐渐增大发送窗口。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。

**拥塞避免**：拥塞避免的算法思路是让拥塞窗口cwnd缓慢增大，每经过一个往返时间RTT，就把发送方的cwnd+1

**快重传和快恢复**：

快重传和快恢复(FRR)是一种拥塞控制算法，它能快速恢复丢失的包。

没有快恢复，如果数据包丢失了，TCP将会使用定时器要求传输暂停。在暂停的这段时间内，没有新的或者复制的数据包被发送。

有了快恢复，接收方如果收到一个不按顺序的数据包，立即给发送方发送一个重复确认。如果发送方收到三个重复确认，它会假设确认件指定的数据段丢失，并立即重传这些丢失的数据段。

有了快恢复，就不会因为重传要求暂停被耽误。

当有单独的数据包丢失时，快重传和快恢复能最有效地工作。

当有多个数据包在某一段很短的时间内丢失时，它则不能很有效地工作。 















### 三、Http





## 操作系统

### 一、死锁

