# JVM、JUC原理总结

## JVM

### 1、JVM内存分为哪几个区？每个区的作用

![JVM内存区域](D:\github\MyKnowledgeRepository\picture\java内存区域.png)



线程私有的：程序计数器、虚拟机栈、本地方法栈

线程共享的：堆、方法区



**程序计数器**

记录正在执行的虚拟机字节码指令的地址



**虚拟机栈**

每个java方法在执行的同时会创建一个栈帧，用于存储局部变量表、操作数栈、常量池引用等信息。

从方法调用直至完成的过程，对应着一个栈帧在java虚拟机栈中入栈和出栈的过程

![**虚拟机栈**](D:\github\MyKnowledgeRepository\picture\java虚拟机栈.png)



**本地方法栈**

本地方法栈和虚拟机栈类似，它们之间的区别是本地方法栈为本地方法服务

本地方法一般是用其他语言(C、C++)编写的，编译为基于本地硬件和操作系统的程序。



**堆**

所有对象都在这里分配内存，是垃圾收集的主要区域

java堆可以细分为：新生代和老年代

新生代还可以细分为：Eden、from survivor、to survivor



**方法区**

用于存放已被加载的类信息、常量、静态变量等信息



虚拟机把它当永久代来进行垃圾回收，但很难确定永久代的大小，因为它受很多因素的影响，每次Full GC后，永久代的大小都会改变，经常抛出OutOfMemoryError的异常。为了更容易管理方法区，从JDK1.8开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中



![jdk1.8内存区域](D:\github\MyKnowledgeRepository\picture\JDK1.8内存区域.png)



### 2、Java类加载的过程

类加载的过程包括：加载、验证、准备、解析、初始化等5个过程

1. 加载

   加载过程完成三件事情：

   - 通过类的全限定名称获取该类的二进制流
   - 将该二进制流中的静态存储结构转化为方法区运行时的数据结构
   - 在内存中生成该类的class对象，作为该类的数据访问入口

2. 验证

   确保class文件的字节流中的信息不会危害到虚拟机

3. 准备

   准备阶段是为类变量分配内存并且设置初始值，使用的是方法区的内存。

   实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起分配在堆中。

   可以发现，实例化不是类加载的过程，类加载发生在所有实例化之前，并且类加载只进行一次，实例化可以进行多次。

4. 解析

   该阶段主要完成符号引用到直接引用的转换动作

5. 初始化

   初始化阶段才是真正执行类中定义的java代码。初始化阶段是虚拟机执行类构造器方法的过程。



### 3、垃圾收集算法

1. **标记-清除**

   该算法分为“标记”和“清除”阶段，首先标记出所有不需要清除的对象，在标记完成后同一回收掉没有被标记的对象。

   不足：

   标记和清除的过程效率不高

   会产生大量不连续内存碎片

   ![标记清除](D:\github\MyKnowledgeRepository\picture\标记清除算法.png)

   

2. **标记-整理**

   把所有存活的对象移到一端，然后清理掉端边界的以外的所有内存

   优点：不会产生内存碎片

   缺点：需要移动大量对象，处理效率比较低

   ![标记整理](D:\github\MyKnowledgeRepository\picture\标记整理算法.png)

   

3. **标记-复制**

   将内存分为大小相同的两块，每次使用其中一块。当一块内存使用完之后，将存活的对象复制到另一块，然后把使用过的内存空间清理掉

   主要不足是只使用了内存的另一半

   ![标记复制](D:\github\MyKnowledgeRepository\picture\标记复制算法.png)

   

   

4. **分代收集**

   它根据对象存活周期将内存分为几块，不同块采用适当的收集算法

   一般将堆分为新生代和老年代

   - 新生代：使用标记-复制算法
   - 老年代：使用标记-清除或标记-整理

   

### 4、如何判断对象是否存活

**1、应用计数算法**

为对象添加一个引用计数器，每当有一个地方引用它，计数器加1；当引用失效，计数器减1。计数为0时，对象可回收。

优点：简单、高效

缺点：很难解决对象之间相互引用的问题

**2、可达性分析算法**

以GC Roots为起始点进行搜索，可到达的对象都是存活的，不可达到的对象可被回收的

![可达性分析算法](D:\github\MyKnowledgeRepository\picture\可达性分析算法.png)





### 5、什么是类加载器，类加载器有哪些？

通过类的全限定名获取类的二进制字节流的代码块叫做类加载器



主要有以下四类加载器：

1. 启动类加载器。用于加载java的核心类库，无法被java程序直接引用
2. 扩展类加载器。用于加载java的扩展类库
3. 系统类加载器。也叫应用类加载器。它根据java应用的类路径来加载java类
4. 用户自定义加载器。通过继承java.lang.ClassLoader类的方式来实现



### 6、Java内存分配与回收策略(Minor GC和Full GC)

Minor GC：回收新生代。新生代对象存活时间很短，因此Minor GC会频繁执行，执行速度一般比较快

Full GC：回收老年代和新生代。老年代对象存活时间长，因此Full GC很少执行，执行速度比Minor GC慢很多



**内存分配和回收**

1. **对象优先在Eden分配**
   - 大多数情况下，对象都是在新生代Eden上分配，当Eden空间不足，发起Minor GC
2. **大对象直接进入老年代**
   - 大对象是指需要连续内存的空间对象，比如很长的字符串或者数组
   - 经常出现大对象会提前触发垃圾收集，以获得足够的连续空间分配给大对象
   - 可以设置此值，大于此值的对象直接进入老年代，避免在Eden和Survivor之间大量内存复制
3. **长期存活对象进入老年代**
   - 为对象定义一个年龄计数器，对象经过Eden出生以及Minor GC依然存活，移动到Survivor区，年龄加1。增加到一定年龄，移动到老年代。
4. **动态对象年龄判定**
   - 不是非要对象达到指定年龄才能进入老年代，如果Survivor中相同年龄的所有对象，大小总和大于Survivor空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需达到指定的年龄。
5. **空间担保机制**
   - 在发生Minor GC前，如果老年代的内存空间不能担保发生Minor GC安全的话，那么就进行Full GC，清理老年代的内存空间。



## JUC

#### 1、Synchronized与Lock的区别

1. Synchronized能实现的功能，Lock都能实现，而且Lock比Synchronized更好用更灵活
2. Synchronized可以自动上锁和解锁，Lock需要手动上锁和解锁



#### 2、Runnable和Callable的区别

1. Runnable接口没有返回值，Callable接口有返回值
2. Runnable接口的方法没有抛出异常，Callable接口的方法抛出异常



#### 3、什么是分布式？分布式CAP理论是什么？

分布式是通过网络交换信息，彼此相互协作而形成的系统。



CAP理论是指在分布式系统中，一致性、可用性、分区容错性三者不可兼得

分区容错是指区间通信可能失败，系统不能在时限内保持数据一致性。

一致性是指在分布式所有数据备份中，在同一时刻是否同样的值。

可用性是指集群一部分节点出现故障后，集群整体是否还能响应客户端的读写请求



#### 4、什么是分布式锁？

在分布式模型下，数据只有一份，此时需要利用锁技术控制某一时刻修改数据的进程数。

分布式与单机最大的不同不是多线程而是多进程。

多线程可以共享堆内存，可以采取内存作为标记存储的位置。

而进程之间可能不再同一台主机上，因此分布式锁可以标记存在所有进程都可以看到的公共内存，比如Redis、Memcache。

与单机模式下的锁不同，分布式锁不仅要考虑进程可见性，还要考虑进程与锁之间的网络通信问题。



#### 5、什么是分布式事务？

分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点上。

简单地说就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，分布式事务需要保证这些小的操作要么全部成功，要么全部失败。

本质上来说，分布式事务就是保证不同数据库的数据一致性。





















