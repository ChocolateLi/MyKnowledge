# JVM、JUC原理总结

## JVM

### 1、JVM内存分为哪几个区？每个区的作用

![JVM内存区域](D:\github\MyKnowledgeRepository\picture\java内存区域.png)



线程私有的：程序计数器、虚拟机栈、本地方法栈

线程共享的：堆、方法区



**程序计数器**

记录正在执行的虚拟机字节码指令的地址



**虚拟机栈**

每个java方法在执行的同时会创建一个栈帧，用于存储局部变量表、操作数栈、常量池引用等信息。

从方法调用直至完成的过程，对应着一个栈帧在java虚拟机栈中入栈和出栈的过程

![**虚拟机栈**](D:\github\MyKnowledgeRepository\picture\java虚拟机栈.png)



**本地方法栈**

本地方法栈和虚拟机栈类似，它们之间的区别是本地方法栈为本地方法服务

本地方法一般是用其他语言(C、C++)编写的，编译为基于本地硬件和操作系统的程序。



**堆**

所有对象都在这里分配内存，是垃圾收集的主要区域

java堆可以细分为：新生代和老年代

新生代还可以细分为：Eden、from survivor、to survivor



**方法区**

用于存放已被加载的类信息、常量、静态变量等信息



虚拟机把它当永久代来进行垃圾回收，但很难确定永久代的大小，因为它受很多因素的影响，每次Full GC后，永久代的大小都会改变，经常抛出OutOfMemoryError的异常。为了更容易管理方法区，从JDK1.8开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中



![jdk1.8内存区域](D:\github\MyKnowledgeRepository\picture\JDK1.8内存区域.png)



### 2、Java类加载的过程

类加载的过程包括：加载、验证、准备、解析、初始化等5个过程

1. 加载

   加载过程完成三件事情：

   - 通过类的全限定名称获取该类的二进制流
   - 将该二进制流中的静态存储结构转化为方法区运行时的数据结构
   - 在内存中生成该类的class对象，作为该类的数据访问入口

2. 验证

   确保class文件的字节流信息不会危害到虚拟机

3. 准备

   准备阶段是为类变量分配内存并且设置初始值，使用的是方法区的内存。

   实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起分配在堆中。

   可以发现，实例化不是类加载的过程，类加载发生在所有实例化之前，并且类加载只进行一次，实例化可以进行多次。

4. 解析

   该阶段主要完成符号引用到直接引用的转换动作

5. 初始化

   初始化阶段才是真正执行类中定义的java代码。初始化阶段是虚拟机执行类构造器方法的过程。



### 3、垃圾收集算法

1. **标记-清除**

   该算法分为“标记”和“清除”阶段，首先标记出所有不需要清除的对象，在标记完成后同一回收掉没有被标记的对象。

   不足：

   标记和清除的过程效率不高

   会产生大量不连续内存碎片

   ![标记清除](D:\github\MyKnowledgeRepository\picture\标记清除算法.png)

   

2. **标记-整理**

   把所有存活的对象移到一端，然后清理掉端边界的以外的所有内存

   优点：不会产生内存碎片

   缺点：需要移动大量对象，处理效率比较低

   ![标记整理](D:\github\MyKnowledgeRepository\picture\标记整理算法.png)

   

3. **标记-复制**

   将内存分为大小相同的两块，每次使用其中一块。当一块内存使用完之后，将存活的对象复制到另一块，然后把使用过的内存空间清理掉

   主要不足是只使用了内存的另一半

   ![标记复制](D:\github\MyKnowledgeRepository\picture\标记复制算法.png)

   

   

4. **分代收集**

   它根据对象存活周期将内存分为几块，不同块采用适当的收集算法

   一般将堆分为新生代和老年代

   - 新生代：使用标记-复制算法
   - 老年代：使用标记-清除或标记-整理

   

### 4、如何判断对象是否存活

**1、引用计数算法**

为对象添加一个引用计数器，每当有一个地方引用它，计数器加1；当引用失效，计数器减1。计数为0时，对象可回收。

优点：简单、高效

缺点：很难解决对象之间相互引用的问题

**2、可达性分析算法**

以GC Roots为起始点进行搜索，可到达的对象都是存活的，不可达到的对象可被回收的

![可达性分析算法](D:\github\MyKnowledgeRepository\picture\可达性分析算法.png)





### 5、什么是类加载器，类加载器有哪些？

通过类的全限定名获取类的二进制字节流的代码块叫做类加载器



主要有以下四类加载器：

1. 启动类加载器。用于加载java的核心类库，无法被java程序直接引用
2. 扩展类加载器。用于加载java的扩展类库
3. 系统类加载器。也叫应用类加载器。它根据java应用的类路径来加载java类
4. 用户自定义加载器。通过继承java.lang.ClassLoader类的方式来实现



### 6、Java内存分配与回收策略(Minor GC和Full GC)

Minor GC：回收新生代。新生代对象存活时间很短，因此Minor GC会频繁执行，执行速度一般比较快

Full GC：回收老年代和新生代。老年代对象存活时间长，因此Full GC很少执行，执行速度比Minor GC慢很多



**内存分配和回收**

1. **对象优先在Eden分配**
   - 大多数情况下，对象都是在新生代Eden上分配，当Eden空间不足，发起Minor GC
2. **大对象直接进入老年代**
   - 大对象是指需要连续内存的空间对象，比如很长的字符串或者数组
   - 经常出现大对象会提前触发垃圾收集，以获得足够的连续空间分配给大对象
   - 可以设置此值，大于此值的对象直接进入老年代，避免在Eden和Survivor之间大量内存复制
3. **长期存活对象进入老年代**
   - 为对象定义一个年龄计数器，对象经过Eden出生以及Minor GC依然存活，移动到Survivor区，年龄加1。增加到一定年龄，移动到老年代。
4. **动态对象年龄判定**
   - 不是非要对象达到指定年龄才能进入老年代，如果Survivor中相同年龄的所有对象，大小总和大于Survivor空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需达到指定的年龄。
5. **空间担保机制**
   - 在发生Minor GC前，如果老年代的内存空间不能担保发生Minor GC安全的话，那么就进行Full GC，清理老年代的内存空间。



## JUC

### 1、Synchronized与Lock的区别

1. Synchronized能实现的功能，Lock都能实现，而且Lock比Synchronized更好用更灵活
2. Synchronized可以自动上锁和解锁，Lock需要手动上锁和解锁



### 2、Runnable和Callable的区别

1. Runnable接口没有返回值，Callable接口有返回值
2. Runnable接口的方法没有抛出异常，Callable接口的方法抛出异常



### 3、什么是分布式？分布式CAP理论是什么？

分布式是通过网络交换信息，彼此相互协作而形成的系统。



CAP理论是指在分布式系统中，一致性、可用性、分区容错性三者不可兼得

一致性是指在分布式所有数据备份中，在同一时刻是否同样的值。

可用性是指集群一部分节点出现故障后，集群整体是否还能响应客户端的读写请求。

分区容错是指区间通信可能失败，系统不能在时限内保持数据一致性。



### 4、什么是分布式锁？

在分布式模型下，数据只有一份，此时需要利用锁技术控制某一时刻修改数据的进程数。

分布式与单机最大的不同不是多线程而是多进程。

多线程可以共享堆内存，可以采取内存作为标记存储的位置。

而进程之间可能不再同一台主机上，因此分布式锁可以标记在所有进程都可以看到的公共内存，比如Redis、Memcache。

与单机模式下的锁不同，分布式锁不仅要考虑进程可见性，还要考虑进程与锁之间的网络通信问题。



### 5、什么是分布式事务？

分布式事务是指事务的参与者分别位于分布式系统的不同节点上。

简单地说就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，分布式事务需要保证这些小的操作要么全部成功，要么全部失败。

本质上来说，分布式事务就是保证不同数据库的数据一致性。



### 6、线程池

#### 为什么使用线程池

池化技术的主要思想是减少每次获取资源的消耗，提高对资源的利用率。

#### 线程池实现原理

一个线程集合workset和一个阻塞队列workqueue，当用户向线程池提交一个任务时（也就是线程），线程池会先将任务放到workqueue中，workset中的线程会不断地从workqueue中获取任务然后执行。当workqueue中没有任务的时候，worker就会阻塞，直到队列中有了任务就取出来继续执行。

![线程池实现原理](D:\github\MyKnowledgeRepository\picture\线程池实现原理.png)



#### 线程池几个主要参数

```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler)

```

**corePoolSize**：规定线程池有几个核心线程在运行

**maximumPoolSize**：当WorkQueue满时，不能添加任务时，这个参数才生效。规定线程池最多只能有几个线程在执行

**keepAliveTime**：超过corePoolSize大小的那些线程的生存时间，如果这些线程长时间没有执行任务并且超过keepAliveTime设定的时间，就会消亡。

**unit**：keepAliveTime参数的时间单位

**workQueue**：存放任务的队列

**threadFactory**：创建线程的工厂

**handler**：当workQueue已满，并且线程池已经达到maximumPoolSize，执行拒绝策略

 

#### 线程池工作流程

用户提交一个任务，线程池执行如下流程：

1. 判断核心线程池是否已满，如果未满，创建一个核心线程执行该任务。
2. 如果核心线程已满，将任务加入到队列中。
3. 如果队列已满，判断线程池是否已满，如果未满就创建非核心线程执行任务。
4. 如果线程池已满，采用拒绝策略。

![线程池工作流程](D:\github\MyKnowledgeRepository\picture\线程池工作流程.png)





#### 线程池种类（java自带哪几种线程池）

- newSingleThreadExecutor。创建唯一的工作线程执行任务。单工作线程最大的特点是可保证顺序地执行各个任务。
- newFixedThreadPool。创建指定线程数的线程池。该线程池节省了创建线程时的开销，但是当线程池没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源
- newCachedThreadPool。创建一个可缓存线程池。它可灵活地回收空闲线程，若无可回收，则创建新线程。它的特点是可灵活的往线程池中添加线程。
- newScheduleThreadPool。该线程池可以指定延迟多少时间执行或者周期性执行



#### 线程池的状态

**Running**

线程池处于running状态时，能够接收新的任务，并且对已添加的任务进行处理

线程池初始状态为running状态



**ShutDown**

线程池处于shutdown状态时，不接收新的任务，但能处理已添加的任务

调用shutdown接口，线程池由running -> shutdown



**Stop**

线程池处于stop状态，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务

调用shutdownnow接口，线程池 由running或shutdown -> stop



**Tidying**

当所有的任务已终止，线程池会变为tidying状态

当线程池处于shutdown状态，阻塞队列为空，并且线程池中执行的任务也为空，就会由shutdown -> tidying

当线程池处于stop状态，线程池中执行的任务为空，就会由stop -> tidying



**Terminated**

线程池彻底终止

线程池处于tidying状态，执行完terminated()方法之后，就会由tidying -> terminated



![线程池状态](D:\github\MyKnowledgeRepository\picture\线程池状态.png)



















